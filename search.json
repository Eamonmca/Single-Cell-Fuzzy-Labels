[
  {
    "objectID": "knn_label_transfer.html",
    "href": "knn_label_transfer.html",
    "title": "KNN Label Transfer",
    "section": "",
    "text": "We will utilize FAISS to identify the nearest neighbor for each cell in the query dataset from the reference dataset. After identifying the nearest neighbor, we will assign the annotation of the cell in the query dataset to match the annotation of its nearest neighbor in the reference dataset. Thanks to Meta’s optimization of FAISS, we can perform these nearest neighbor searches in batches and on the GPU, which significantly speeds up the process. The IndexFlatL2 function is used to calculate the L2 (or Euclidean) distance between all points in our query vector and the vectors in the reference index. A diagram illustrating this process is provided below. For more detailed information on vector searches and maximizing the use of FAISS, refer to the link provided (image credit also included).\nWhen the K value in our K-Nearest Neighbors (KNN) algorithm is set to more than one neighbor, we need a method to determine the final predicted label. This is essential for ensuring the accuracy and reliability of our classification tasks. Below, we will implement three methods for this purpose:\n\nMajority Voting Method\nThe Majority Voting Method is a technique used to determine the final label for each data point in the query dataset. This is achieved by conducting a simple majority vote among the labels of the K nearest neighbors in the reference dataset. The process involves the following steps:\n\nNeighbor Identification: For every data point in the query dataset, the K nearest neighbors in the reference dataset are identified.\nVote Counting: The labels of these K neighbors are tallied.\nLabel Assignment: The label with the highest tally is assigned to the query data point.\n\nIt is important to note that this method assumes that each of the K neighbors has equal significance.\n\nsource\n\nknn_majority_voting\n\n knn_majority_voting (indices:List[List[int]], reference_labels:List[str])\n\nAssigns labels to query dataset points using majority voting from k-nearest neighbors.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nindices\ntyping.List[typing.List[int]]\nA list of lists, where each sublist contains the indices of the k-nearest neighbors in the reference dataset for a given query point.\n\n\nreference_labels\ntyping.List[str]\nA list of labels corresponding to the points in the reference dataset.\n\n\nReturns\ntyping.List[str]\nA list of labels for each point in the query dataset, determined by majority voting.\n\n\n\n\n\n\nWeighted Voting Method\nThe Weighted Voting Method is a technique that considers both the labels and the distances of the K nearest neighbors from the reference dataset. This method is especially beneficial when the neighbors are at different distances from the query point. The process involves the following steps:\n\nNeighbor and Distance Identification: For each query point, the K nearest neighbors and their distances from the query point are identified.\nWeighted Vote Calculation: Each neighbor is assigned a weight based on its distance (neighbors closer to the query point are given higher weight).\nVote Aggregation: The weighted votes for each label are aggregated.\nLabel Assignment: The label with the highest aggregated weight is assigned to the query point.\n\nThis method allows neighbors that are closer to the query point to have more influence, potentially leading to more accurate predictions, especially in scenarios where the nearest neighbors are not uniformly distributed around the query point.\n\nsource\n\nknn_weighted_voting\n\n knn_weighted_voting (indices:List, distances:List, reference_labels:List)\n\nAssigns labels to query dataset points using weighted voting from k-nearest neighbors.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nindices\ntyping.List\nA list of lists, where each sublist contains the indices of the k-nearest neighbors in the reference dataset for a given query point.\n\n\ndistances\ntyping.List\nA list of lists, where each sublist contains the distances of the k-nearest neighbors from a given query point.\n\n\nreference_labels\ntyping.List\nA list of labels corresponding to the points in the reference dataset.\n\n\nReturns\ntyping.List[str]\nA list of labels for each point in the query dataset, determined by weighted voting.\n\n\n\n\n\n\nCentroid-Based Label Assignment\nThe Centroid-Based Label Assignment method assigns labels to data points in a query dataset based on their closeness to the centroids of different classes in a reference dataset. The centroids are the average position of all points within a specific class. Here’s a detailed breakdown of the process:\n\nCentroid Calculation: For each label in the reference dataset, compute the centroid. A centroid is the arithmetic mean position of all the points sharing the same label. This step involves adding up all data points of each label and dividing by the total number of points for that label.\nLabel Assignment by Nearest Centroid: For each point in the query dataset, identify its closest centroid. The closest centroid is the one with the least Euclidean distance from the query point. The label of this nearest centroid is then assigned to the query point.\n\nThis method operates under the assumption that data points of the same class are typically clustered together, with the centroid serving as the central point of these clusters. It is particularly useful in situations where data points of the same class form distinct, compact clusters. However, its performance may be suboptimal in scenarios where the class distribution is highly irregular or overlapping.\n\nsource\n\ncalculate_centroids\n\n calculate_centroids (reference_data:List[List[float]],\n                      reference_labels:List[str])\n\nCalculates the centroids for each label in the reference dataset.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nreference_data\ntyping.List[typing.List[float]]\nA list of lists, where each sublist represents a data point in the reference dataset.\n\n\nreference_labels\ntyping.List[str]\nA list of labels corresponding to the points in the reference dataset.\n\n\nReturns\ntyping.Dict[str, numpy.ndarray]\nReturns a dictionary where each key is a label and the corresponding value is the centroid of that label.\n\n\n\n\nsource\n\n\nassign_labels_by_nearest_centroid\n\n assign_labels_by_nearest_centroid (query_data:List[List[float]],\n                                    centroids:Dict[str,numpy.ndarray])\n\nAssigns labels to each point in the query dataset based on the nearest centroid.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nquery_data\ntyping.List[typing.List[float]]\nA list of lists, where each sublist represents a data point in the query dataset.\n\n\ncentroids\ntyping.Dict[str, numpy.ndarray]\nA dictionary where each key is a label and the corresponding value is the centroid of that label.\n\n\nReturns\ntyping.List[str]\nReturns a list of labels assigned to each point in the query dataset based on the nearest centroid.\n\n\n\n\n\n\nRunning the Label Transfer\nThe following section of code implements our label transfer algorithm using FAISS. This function is designed to produce a very simple label transfer under default conditions, i.e., when ( k = 1 ). In this case, there is no need for label consensus as there is only one nearest neighbor.\nHowever, the function also provides the flexibility to vary ( k ), the number of nearest neighbors considered for label assignment. When ( k &gt; 1 ), a label consensus method is required to decide the label for the query point based on the labels of its ( k ) nearest neighbors. The function supports three label consensus methods: ‘majority_voting’, ‘weighted_voting’, and ‘centroid_based’.\n‘majority_voting’ assigns the label that appears most frequently among the ( k ) nearest neighbors. In case of a tie, it selects the label of the closest neighbor among the tied labels.\n‘weighted_voting’ assigns the label based on a weighted vote where closer neighbors have a higher weight. The weight of each neighbor is inversely proportional to its distance from the query point.\n‘centroid_based’ assigns labels to data points in the query dataset based on their closeness to the centroids of different classes in the reference dataset. This method is particularly useful in situations where data points of the same class form distinct, compact clusters.\nThe function also allows the distance metric to be varied according to any metric supported by FAISS. This provides additional flexibility in handling different types of data distributions.\n\nsource\n\nlabels\n\n labels (embedding_array_reference:numpy.ndarray,\n         embedding_array_query:numpy.ndarray, reference_labels:List[str],\n         k:int=1, use_gpu:bool=True, batch_size:Optional[int]=None,\n         distance_metric:str='L2', label_consensus:str='majority_voting',\n         timed:bool=False)\n\nTransfers labels from a reference dataset to a query dataset using FAISS.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nembedding_array_reference\nndarray\n\nA numpy array representing the reference dataset.\n\n\nembedding_array_query\nndarray\n\nA numpy array representing the query dataset.\n\n\nreference_labels\ntyping.List[str]\n\nA list of labels for the reference dataset.\n\n\nk\nint\n1\nThe number of nearest neighbors to consider for label assignment.\n\n\nuse_gpu\nbool\nTrue\nWhether to use GPU for computation.\n\n\nbatch_size\ntyping.Optional[int]\nNone\nThe size of the batch for computation. If None, the entire query dataset is processed in one batch.\n\n\ndistance_metric\nstr\nL2\nThe distance metric to use. Can be ‘L2’ or ‘IP’.\n\n\nlabel_consensus\nstr\nmajority_voting\nThe label consensus method to use. Can be ‘majority_voting’, ‘weighted_voting’, or ‘centroid_based’.\n\n\ntimed\nbool\nFalse\nWhether to return the time taken for label transfer.\n\n\nReturns\ntyping.Union[typing.List[str], typing.Tuple[typing.List[str], float]]\n\nReturns a list of labels for the query dataset. If timed is True, also returns the time taken for label transfer.",
    "crumbs": [
      "KNN Label Transfer"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Single-Cell-Fuzzy-Labels",
    "section": "",
    "text": "Single-Cell Fuzzy Labels Concept",
    "crumbs": [
      "Single-Cell-Fuzzy-Labels"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "Single-Cell-Fuzzy-Labels",
    "section": "Install",
    "text": "Install\ngit clone https://github.com/Eamonmca/Single-Cell-Fuzzy-Labels\ncd Single-Cell-Fuzzy-Labels\npip install .",
    "crumbs": [
      "Single-Cell-Fuzzy-Labels"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "Single-Cell-Fuzzy-Labels",
    "section": "How to use",
    "text": "How to use\nIn this notebook, we are demonstrating the use of the Single_Cell_Fuzzy_Labels library. This library is designed to facilitate the transfer of labels from a well-annotated reference dataset to a query dataset in single-cell RNA sequencing (scRNA-seq) studies. The library provides functions for label transfer, visualization of label transfers, and harmonization of cell labels.\nThe process begins with the extraction of Universal Cell Embeddings (UCE) from both the reference and query datasets. The UCE is a lower-dimensional representation of the datasets that is used for label transfer.\nThe transfer.labels function is then used to perform the label transfer. This function takes several parameters including the UCE of the reference and query datasets, the labels from the reference dataset that we want to transfer, and the number of nearest neighbors to consider when transferring labels.\nAfter the label transfer, the viz module is used to visualize the label transfers and the distribution of the transferred labels. This helps in understanding how well the labels from the reference dataset map to the cells in the query dataset.\nFinally, the harmonise module is used to match the cell labels in the query dataset with those in the reference dataset. This is done by creating a dictionary that maps each unique label in the query dataset to a corresponding label in the reference dataset. We leverage the reasoning capabilitys of GPT-4 to do this using the openAI API.\n\nfrom Single_Cell_Fuzzy_Labels import census\nimport scanpy as sc \nimport matplotlib.pyplot as plt\nimport warnings\nfrom dotenv import load_dotenv\nload_dotenv()\nwarnings.filterwarnings('ignore')\n\nIn the following section, we will be loading the reference dataset. This dataset is a pre-embedded data from the cellxgene census, which contains a vast dataset of 33 million cells. We will be using the ‘homo_sapiens’ organism and ‘lung’ tissue for this example. The data is loaded using the ‘read_h5ad’ function from the ‘scanpy’ library.\nAfter loading the data, we will subset it to only include ‘Epithelial’ cells. This is done by filtering the ‘ann_level_1’ column of the ‘obs’ attribute of the ‘reference’ object. The subset is then assigned back to the ‘reference’ object.\nWe will then display the ‘X_uce’ attribute of the ‘obsm’ attribute of the ‘reference’ object. This attribute contains the Universal Cell Embeddings for the ‘reference’ object.\n\n# reference = census.download_emb(organism='homo_sapiens', tissue='lung', test = True)\nreference = sc.read_h5ad('/data/analysis/data_mcandrew/000-sc-UCA-test/uce/HCA_lung_core__uce_adata.h5ad')\n\n\nreference\n\nAnnData object with n_obs × n_vars = 584944 × 18166\n    obs: 'suspension_type', 'donor_id', 'is_primary_data', 'assay_ontology_term_id', 'cell_type_ontology_term_id', 'development_stage_ontology_term_id', 'disease_ontology_term_id', 'self_reported_ethnicity_ontology_term_id', 'tissue_ontology_term_id', 'organism_ontology_term_id', 'sex_ontology_term_id', 'BMI', 'age_or_mean_of_age_range', 'age_range', 'anatomical_region_ccf_score', 'ann_coarse_for_GWAS_and_modeling', 'ann_finest_level', 'ann_level_1', 'ann_level_2', 'ann_level_3', 'ann_level_4', 'ann_level_5', 'cause_of_death', 'dataset', 'entropy_dataset_leiden_3', 'entropy_original_ann_level_1_leiden_3', 'entropy_original_ann_level_2_clean_leiden_3', 'entropy_original_ann_level_3_clean_leiden_3', 'entropy_subject_ID_leiden_3', 'fresh_or_frozen', 'leiden_1', 'leiden_2', 'leiden_3', 'leiden_4', 'leiden_5', 'log10_total_counts', 'lung_condition', 'mixed_ancestry', 'n_genes_detected', 'original_ann_highest_res', 'original_ann_level_1', 'original_ann_level_2', 'original_ann_level_3', 'original_ann_level_4', 'original_ann_level_5', 'original_ann_nonharmonized', 'reannotation_type', 'reference_genome', 'sample', 'scanvi_label', 'sequencing_platform', 'size_factors', 'smoking_status', 'study', 'subject_type', 'tissue_dissociation_protocol', 'tissue_level_2', 'tissue_level_3', 'tissue_sampling_method', 'tissue_type', 'cell_type', 'assay', 'disease', 'organism', 'sex', 'tissue', 'self_reported_ethnicity', 'development_stage', 'observation_joinid', 'n_genes'\n    var: 'feature_is_filtered', 'feature_name', 'feature_reference', 'feature_biotype', 'feature_length', 'n_cells'\n    uns: 'batch_condition', 'citation', 'default_embedding', 'schema_reference', 'schema_version', 'title'\n    obsm: 'X_scanvi_emb', 'X_uce', 'X_umap'\n    obsp: 'connectivities', 'distances'\n\n\n\nreference_subset = reference[reference.obs['ann_level_1'] == 'Epithelial']\n\n\nreference = reference_subset\n\n\nreference.obsm['X_uce']\n\nArrayView([[ 0.00750788, -0.04194154,  0.00931572, ...,  0.03899895,\n            -0.02080086, -0.01758753],\n           [ 0.02603231,  0.03415936, -0.00083805, ...,  0.01040316,\n             0.00231683,  0.07622543],\n           [ 0.01907516, -0.03912187,  0.01917193, ...,  0.02607882,\n             0.02887304, -0.00058624],\n           ...,\n           [ 0.00766119, -0.03144012,  0.00277021, ...,  0.03181685,\n             0.00958184,  0.01409992],\n           [-0.0129706 ,  0.04543586, -0.00394633, ..., -0.01092251,\n             0.01244534,  0.01408385],\n           [-0.0060271 ,  0.00604395,  0.01479142, ..., -0.00512656,\n            -0.01186521,  0.02647699]], dtype=float32)\n\n\nNow, we will import our query dataset. This dataset has been preprocessed and the embeddings have been precomputed using the instructions provided on the Universal Cell Embeddings (UCE) GitHub page. Next, we will leverage our well-annotated reference dataset to predict the labels in our query dataset. This process is crucial as it allows us to infer the cell types in the query dataset based on the known labels in the reference dataset. This is achieved by comparing the embeddings of cells in both datasets and assigning the labels from the nearest neighbors in the reference dataset to the cells in the query dataset. The Single_Cell_Fuzzy_Labels library provides an efficient and accurate method for this label transfer process.\n\nquery = sc.read_h5ad('/data/analysis/data_mcandrew/000-sc-UCA-test/uce/HBECS_ALI28_uce_adata.h5ad')\n\n\nquery\n\nAnnData object with n_obs × n_vars = 10224 × 14949\n    obs: 'orig.ident', 'nCount_RNA', 'nFeature_RNA', 'nCount_HTO', 'nFeature_HTO', 'HTO_maxID', 'HTO_secondID', 'HTO_margin', 'HTO_classification', 'HTO_classification.global', 'hash.ID', 'percent.mito', 'percent.ribo', 'dropouts', 'nCount_SCT', 'nFeature_SCT', 'SCT_snn_res.0.4', 'seurat_clusters', 'echantillon', 'donor', 'medium', 'sample', 'type', 'batch', 'type_pred', 'type_uncertainty', 'leiden', 'RNA_snn_res.1', 'cluster_l1', 'celltype_l1', 'ident', 'n_genes'\n    var: 'n_cells'\n    uns: 'X_name'\n    obsm: 'SCANVI', 'UMAP', 'X_uce'\n    layers: 'logcounts'\n\n\n\nquery.obsm['X_uce']\n\narray([[ 0.0045417 , -0.0086563 ,  0.01687446, ...,  0.02272223,\n        -0.01826951, -0.01024585],\n       [ 0.01364084, -0.00542254,  0.01779299, ...,  0.01887637,\n        -0.00538362,  0.00553044],\n       [ 0.00350829,  0.01183089,  0.01040006, ...,  0.01037928,\n        -0.01872197, -0.01138068],\n       ...,\n       [-0.00063122, -0.01984753,  0.02148496, ...,  0.00014579,\n         0.01573275, -0.00872346],\n       [ 0.00331486, -0.00467246, -0.02007541, ...,  0.01982483,\n         0.00755446,  0.00302285],\n       [-0.00757075,  0.01373623,  0.01243316, ...,  0.03014414,\n        -0.01670015, -0.01620588]], dtype=float32)\n\n\n\nfrom Single_Cell_Fuzzy_Labels import transfer\n\nIn this step, we perform the label transfer using the ‘transfer.labels’ function from the Single_Cell_Fuzzy_Labels library. This function takes in the embeddings of the reference and query datasets, the labels of the reference dataset, and several other parameters to control the label transfer process. The function uses a nearest neighbors approach to assign labels from the reference dataset to the query dataset. This is a crucial step in our analysis as it allows us to infer the cell types in the query dataset based on the known labels in the reference dataset.\n\npredicted_labels = transfer.labels(embedding_array_reference=reference.obsm['X_uce'], \n                          embedding_array_query=query.obsm['X_uce'], \n                          reference_labels=reference.obs['ann_finest_level'], \n                          k=1, \n                          use_gpu=True, \n                          batch_size=None, \n                          distance_metric='L2', \n                          label_consensus='centroid_based', \n                          timed=False)\n\n\nquery.obs['predicted_labels'] = predicted_labels\n\n\nquery.obs['celltype_l1'].head(10)\n\nDonor1_ALI28_AAACCTGAGCCACCTG    Suprabasal\nDonor1_ALI28_AAACCTGAGCTCAACT         Basal\nDonor1_ALI28_AAACCTGAGTAAGTAC         Basal\nDonor1_ALI28_AAACCTGCAAACCCAT         Basal\nDonor1_ALI28_AAACCTGGTCCTAGCG     Secretory\nDonor1_ALI28_AAACCTGGTCTCGTTC        Goblet\nDonor1_ALI28_AAACCTGTCATACGGT    Suprabasal\nDonor1_ALI28_AAACCTGTCCATGAGT     Secretory\nDonor1_ALI28_AAACCTGTCCGCGTTT         Basal\nDonor1_ALI28_AAACGGGAGAGTAATC     Secretory\nName: celltype_l1, dtype: category\nCategories (9, object): ['Basal', 'Cycling Basal', 'Deuterosomal', 'Multiciliated', ..., 'Squamous', 'Secretory', 'Goblet', 'Rare cells']\n\n\n\npredicted_labels[:10]\n\n['Basal resting',\n 'Basal resting',\n 'Club (nasal)',\n 'Basal resting',\n 'Club (non-nasal)',\n 'Goblet (nasal)',\n 'Club (nasal)',\n 'Suprabasal',\n 'Basal resting',\n 'Club (nasal)']\n\n\n\nfrom Single_Cell_Fuzzy_Labels import viz\n\n\ntransfers = viz.map_label_transfers(query, 'predicted_labels', 'celltype_l1')\n\n\nprint(transfers.head(10))\n\ncelltype_l1               Basal  Cycling Basal  Deuterosomal  Multiciliated  \\\npredicted_labels                                                              \nBasal resting          0.823691       0.125148      0.000000       0.001574   \nClub (nasal)           0.100762       0.021675      0.002343       0.000000   \nClub (non-nasal)       0.003484       0.000581      0.002904       0.000000   \nDeuterosomal           0.037838       0.000000      0.621622       0.275676   \nGoblet (bronchial)     0.000000       0.000000      0.000000       0.000000   \nGoblet (nasal)         0.011701       0.000900      0.009901       0.000900   \nGoblet (subsegmental)  0.000000       0.000000      0.000000       0.000000   \nHillock-like           0.555556       0.157233      0.000000       0.000000   \nIonocyte               0.200000       0.000000      0.000000       0.000000   \nMulticiliated (nasal)  0.000000       0.000000      0.000000       1.000000   \n\ncelltype_l1            Suprabasal  Squamous  Secretory    Goblet  Rare cells  \npredicted_labels                                                              \nBasal resting            0.027155  0.000394   0.020071  0.001181    0.000787  \nClub (nasal)             0.295841  0.042765   0.473345  0.060340    0.002929  \nClub (non-nasal)         0.035424  0.001161   0.448897  0.505807    0.001742  \nDeuterosomal             0.005405  0.005405   0.048649  0.005405    0.000000  \nGoblet (bronchial)       0.000000  0.000000   0.208333  0.791667    0.000000  \nGoblet (nasal)           0.016202  0.027003   0.549055  0.384338    0.000000  \nGoblet (subsegmental)    0.000000  0.000000   0.000000  1.000000    0.000000  \nHillock-like             0.174004  0.109015   0.004193  0.000000    0.000000  \nIonocyte                 0.000000  0.000000   0.800000  0.000000    0.000000  \nMulticiliated (nasal)    0.000000  0.000000   0.000000  0.000000    0.000000  \n\n\n\nviz.visualize_label_distribution(transfers, fuzz1_score=None, title='label transfer distribution')\nplt.show()\n\n\n\n\n\n\n\n\nIn single cell data analysis, a common issue arises when dealing with annotations such as cell types. Even for identical cells, the annotation sets may not match perfectly. This discrepancy can be due to various factors such as differences in annotation methods, different naming conventions, spelling, different resolotions, groupings of subtypes etc.\nSingle-Cell-Fuzzy-Labels, provides a solution to this problem. It uses a fuzzy labeling approach to harmonize the cell type annotations across different datasets. The library leverages the power of natural language processing and reasoning capabilities of GPT-4 to match the cell type labels. It also provides visualization tools to inspect the label transfers and the distribution of labels.\n\nfrom Single_Cell_Fuzzy_Labels import harmonise\n\n\nLabel_alias_dict = harmonise.match_cell_labels(list(query.obs['celltype_l1'].values.unique()), list(query.obs['predicted_labels'].unique()))\n\n\nquery.obs['celltype_l1'].unique()\n\n['Suprabasal', 'Basal', 'Secretory', 'Goblet', 'Deuterosomal', 'Multiciliated', 'Cycling Basal', 'Squamous', 'Rare cells']\nCategories (9, object): ['Basal', 'Cycling Basal', 'Deuterosomal', 'Multiciliated', ..., 'Squamous', 'Secretory', 'Goblet', 'Rare cells']\n\n\n\nprint(query.obs['predicted_labels'].values[:10])\n\n['Basal resting' 'Basal resting' 'Club (nasal)' 'Basal resting'\n 'Club (non-nasal)' 'Goblet (nasal)' 'Club (nasal)' 'Suprabasal'\n 'Basal resting' 'Club (nasal)']\n\n\n\nLabel_alias_dict\n\n{'Basal resting': 'Basal',\n 'Club (nasal)': 'Secretory',\n 'Club (non-nasal)': 'Secretory',\n 'Goblet (nasal)': 'Goblet',\n 'Suprabasal': 'Suprabasal',\n 'Deuterosomal': 'Deuterosomal',\n 'Multiciliated (non-nasal)': 'Multiciliated',\n 'Hillock-like': 'Rare cells',\n 'pre-TB secretory': 'Secretory',\n 'SMG mucous': 'Secretory',\n 'Tuft': 'Rare cells',\n 'Goblet (subsegmental)': 'Goblet',\n 'SMG duct': 'Secretory',\n 'Ionocyte': 'Rare cells',\n 'Multiciliated (nasal)': 'Multiciliated',\n 'Goblet (bronchial)': 'Goblet'}\n\n\nIn this section, we will utilize the ‘harmonise’ function from the Single-Cell-Fuzzy-Labels library. This function is designed to address the common issue in single cell data analysis where identical cells may have different annotations due to various factors such as differences in annotation methods. The ‘harmonise’ function uses a fuzzy labeling approach to match cell type labels across different datasets, thereby enabling more accurate integration and comparison of single cell datasets with different annotation schemas.\n\nquery.obs['mapped_predictions'] = harmonise.map_old_labels_to_new(list(query.obs['predicted_labels'].values), Label_alias_dict)\n\nAdditionally, we will calculate a ‘fuzz_1’ score. This score is a measure of the effectiveness of our fuzzy labeling approach in matching cell type labels across different datasets. It will provide us with a (semi) quantitative assessment of the harmonization process, complementing our visual analysis.\n\nfuzz_1 = viz.calculate_fuzz_1(query, reference_label='celltype_l1', predicted_query_label='mapped_predictions')\ntransfers = viz.map_label_transfers(query, 'mapped_predictions', 'celltype_l1')\nviz.visualize_label_distribution(transfers, fuzz1_score=fuzz_1, title='label transfer distribution', proportions_flag = 'md', matched = True)\nplt.show()\n\n\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\n\nmedium_list = query.obs['medium'].unique().tolist()\nfor medium in medium_list:\n    medium_subset = query[query.obs['medium'] == medium]\n    transfers = viz.map_label_transfers(medium_subset, 'predicted_labels', 'celltype_l1')\n    viz.visualize_label_distribution(transfers, fuzz1_score=None, title=f'label transfer {medium}')\n      \n    plt.tight_layout()\n    plt.show()\n    \n    fuzz_1 = viz.calculate_fuzz_1(medium_subset, reference_label='celltype_l1', predicted_query_label='mapped_predictions')\n    transfers = viz.map_label_transfers(medium_subset, 'mapped_predictions', 'celltype_l1')\n    \n\n    viz.visualize_label_distribution(transfers, fuzz1_score=fuzz_1, title=f'label transfer fuzz_1 {medium}', proportions_flag = 'md', matched = True)\n    \n    plt.tight_layout()\n    plt.show()\n\n\n\n\n\n\n\n\n&lt;Figure size 640x480 with 0 Axes&gt;\n\n\n\n\n\n\n\n\n\n&lt;Figure size 640x480 with 0 Axes&gt;\n\n\n\n\n\n\n\n\n\n&lt;Figure size 640x480 with 0 Axes&gt;\n\n\n\n\n\n\n\n\n\n&lt;Figure size 640x480 with 0 Axes&gt;\n\n\n\n\n\n\n\n\n\n&lt;Figure size 640x480 with 0 Axes&gt;\n\n\n\n\n\n\n\n\n\n&lt;Figure size 640x480 with 0 Axes&gt;\n\n\n\n\n\n\n\n\n\n&lt;Figure size 640x480 with 0 Axes&gt;\n\n\n\n\n\n\n\n\n\n&lt;Figure size 640x480 with 0 Axes&gt;",
    "crumbs": [
      "Single-Cell-Fuzzy-Labels"
    ]
  },
  {
    "objectID": "download_embeddings_census.html",
    "href": "download_embeddings_census.html",
    "title": "Download Embeddings CELLxGENE",
    "section": "",
    "text": "from scanpy import AnnData\n\n\nDownload Pre-Embeded Census Data\nThis function download_census_data is designed to automate the process of downloading census data and retrieving embeddings for a specific organism and tissue type. It takes four parameters: census_version to specify the version of the census data, embedding_uri to provide the location of the embeddings data, organism to filter the data for a particular organism (like “homo_sapiens”), and tissue to specify the tissue type (like “blood”). The function returns an Anndata object that contains the embeddings corresponding to the filtered census data.\n\nsource\n\ndownload_emb\n\n download_emb (census_version:str='2023-12-15',\n               embedding_uri:str='s3://cellxgene-contrib-\n               public/contrib/cell-census/soma/2023-12-15/CxG-contrib-2',\n               organism:str='homo_sapiens', tissue:str='blood',\n               test:bool=False)\n\nDownload census data and retrieve embeddings for the specified organism and tissue with default parameters.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncensus_version\nstr\n2023-12-15\nThe version date of the CELLxGENE census data to be used.\n\n\nembedding_uri\nstr\ns3://cellxgene-contrib-public/contrib/cell-census/soma/2023-12-15/CxG-contrib-2\nThe URI where the embeddings are stored, typically an S3 bucket path.\n\n\norganism\nstr\nhomo_sapiens\nThe scientific name of the organism for which the data is to be filtered.\n\n\ntissue\nstr\nblood\nThe type of tissue for which the data is to be filtered\n\n\ntest\nbool\nFalse\nDefines whether the data should be subsetted to specifically include macrophages to avoid downloading a very large dataset as the test case.\n\n\nReturns\nAnnData\n\nAn Anndata object with the precomputed embeddings\n\n\n\n\n\n\nExample Usage\nThe following code snippet demonstrates how to use the download_and_embed_census_data function to download and embed census data for human blood tissue. The function is called with default parameters for census_version and embedding_uri, while organism and tissue are set to ‘homo_sapiens’ and ‘blood’, respectively. To avoid downloading an extremely large dataset we will use the test case by setting the test lag to true, which is programmed to only download the macrophages. The result is stored in the variable reference, which contains the Anndata object with the embeddings.\n\nreference = download_census_data(organism='homo_sapiens', tissue='blood', test = True)\n\nWe can invoke the Anndata object to inspect its structure and understand the organization of the data it contains.\n\nreference\n\nAnnData object with n_obs × n_vars = 7433 × 60664\n    obs: 'soma_joinid', 'dataset_id', 'assay', 'assay_ontology_term_id', 'cell_type', 'cell_type_ontology_term_id', 'development_stage', 'development_stage_ontology_term_id', 'disease', 'disease_ontology_term_id', 'donor_id', 'is_primary_data', 'self_reported_ethnicity', 'self_reported_ethnicity_ontology_term_id', 'sex', 'sex_ontology_term_id', 'suspension_type', 'tissue', 'tissue_ontology_term_id', 'tissue_general', 'tissue_general_ontology_term_id', 'raw_sum', 'nnz', 'raw_mean_nnz', 'raw_variance_nnz', 'n_measured_vars'\n    var: 'soma_joinid', 'feature_id', 'feature_name', 'feature_length', 'nnz', 'n_measured_obs'\n    obsm: 'emb'\n\n\nWe can access the embeddings generated by the universal cell embeddings model (UCE) which are stored in the ‘emb’ field of the .obsm attribute. embeddings = reference.obsm[‘emb’]\n\nreference.obsm['emb']\n\narray([[-0.03808594, -0.00436401, -0.00092316, ...,  0.02258301,\n         0.01843262, -0.01483154],\n       [ 0.00213623, -0.00836182,  0.02612305, ...,  0.02392578,\n        -0.00515747, -0.01940918],\n       [-0.01513672, -0.00891113,  0.02539062, ...,  0.01312256,\n         0.01538086, -0.01550293],\n       ...,\n       [-0.01538086, -0.01330566, -0.00454712, ..., -0.00640869,\n        -0.00497437,  0.01556396],\n       [-0.01025391,  0.03100586,  0.02111816, ..., -0.02893066,\n         0.00787354,  0.06738281],\n       [ 0.02087402, -0.0324707 ,  0.01879883, ..., -0.01397705,\n        -0.0255127 ,  0.0213623 ]], dtype=float32)\n\n\nEach cell downloaded from the CELLxGENE Discover Census package is represented by a 1280-dimensional vector, as observed in the output below when we check the shape of the embedding.\n\nreference.obsm['emb'].shape\n\n(7433, 1280)",
    "crumbs": [
      "Download Embeddings CELLxGENE"
    ]
  },
  {
    "objectID": "label_set_harmonisation.html",
    "href": "label_set_harmonisation.html",
    "title": "Label Set Harmonisation",
    "section": "",
    "text": "source\n\nmap_old_labels_to_new\n\n map_old_labels_to_new (old_labels:list, label_mapping:dict)\n\nMaps each old label in old_labels to its corresponding new label based on label_mapping.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nold_labels\nlist\nA list of old labels that need to be mapped to new labels\n\n\nlabel_mapping\ndict\nA dictionary where keys are old labels and values are new labels\n\n\nReturns\nlist\nReturns a list of new labels corresponding to each old label in old_labels.\n\n\n\n\nsource\n\n\nmatch_cell_labels\n\n match_cell_labels (existing_labels_set:set, predicted_labels_set:set,\n                    openai_api_key:str=None)\n\nThis function matches cell type labels from two sets using OpenAI’s GPT-4 model.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nexisting_labels_set\nset\n\nA set of existing cell type labels\n\n\npredicted_labels_set\nset\n\nA set of predicted cell type labels\n\n\nopenai_api_key\nstr\nNone\nThe API key for OpenAI. If not provided, it will be taken from the environment variable ‘OPENAI_API_KEY’\n\n\nReturns\ndict\n\nA dictionary representing the JSON object with matched labels.\n\n\n\n\nsource\n\n\nmap_labels_to_categories\n\n map_labels_to_categories (label_list:list, label_dict:dict)\n\nMaps each label in label_list to its corresponding category based on label_dict.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nlabel_list\nlist\nA list of labels that need to be categorized\n\n\nlabel_dict\ndict\nA dictionary where keys are categories and values are lists of labels belonging to those categories\n\n\nReturns\nlist\nReturns a list of categories corresponding to each label in label_list.",
    "crumbs": [
      "Label Set Harmonisation"
    ]
  },
  {
    "objectID": "visualization .html",
    "href": "visualization .html",
    "title": "Visualising the label transfer",
    "section": "",
    "text": "source\n\nvisualize_label_distribution\n\n visualize_label_distribution (proportions, fuzz1_score=None, title='label\n                               transfer distribution',\n                               proportions_flag=None, matched=False)\n\nVisualizes the distribution of annotations using a heatmap.\nArgs: proportions (DataFrame): The proportions of each annotation per label. fuzz1_score (float, optional): The calculated Fuzz1 score. If specified, it will be included in the visualization. title (str): The title of the heatmap. proportions_flag (str, optional): Controls the display of proportions. Use ‘none’ for no annotations, ‘md’ for main diagonal, or ‘all’ for all cells.\nReturns: heatmap (object): The heatmap object.\n\nsource\n\n\ncalculate_fuzz_1\n\n calculate_fuzz_1 (query_dataset, reference_label='type',\n                   predicted_query_label='annot')\n\nCalculates the Fuzz1 score, which is the harmonic mean of precision and recall (akin to the F1 score).\nArgs: query_dataset (DataFrame or similar): Query dataset with annotations. reference_label (str): Column name in query_dataset representing the original labels. predicted_query_label (str): Column name in query_dataset representing the annotations.\nReturns: fuzz1_score (float): The calculated Fuzz1 score.\n\nsource\n\n\nmap_label_transfers\n\n map_label_transfers (query_dataset, reference_label='type',\n                      predicted_query_label='annot')\n\nMaps the label transfers in the query dataset. This function takes into account that the label sets may not necessarily match.\nArgs: query_dataset (AnnData): Query dataset with annotations. reference_label (str): Column name in query_dataset representing the original labels. predicted_query_label (str): Column name in query_dataset representing the transferred labels.\nReturns: label_transfers (DataFrame): A dataframe showing the proportion of each transferred label per original label.",
    "crumbs": [
      "Visualising the label transfer"
    ]
  }
]