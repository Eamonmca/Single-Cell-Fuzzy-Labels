<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="The KNN_Label_transfer module provides functionality for label transfer between datasets using k-nearest neighbors (KNN) algorithms. It includes methods for majority and weighted voting based on nearest neighbors, calculation of centroids for labeled data, and label assignment based on nearest centroids. This module is designed to facilitate the propagation of labels from a reference dataset with known labels to a query dataset where labels are unknown.">

<title>Single-Cell-Fuzzy-Labels - KNN Label Transfer</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
<meta property="og:title" content="Single-Cell-Fuzzy-Labels - KNN Label Transfer">
<meta property="og:description" content="The KNN_Label_transfer module provides functionality for label transfer between datasets using k-nearest neighbors (KNN) algorithms. It includes methods for majority and weighted voting based on nearest neighbors, calculation of centroids for labeled data, and label assignment based on nearest centroids. This module is designed to facilitate the propagation of labels from a reference dataset with known labels to a query dataset where labels are unknown.">
<meta property="og:site_name" content="Single-Cell-Fuzzy-Labels">
<meta name="twitter:title" content="Single-Cell-Fuzzy-Labels - KNN Label Transfer">
<meta name="twitter:description" content="The KNN_Label_transfer module provides functionality for label transfer between datasets using k-nearest neighbors (KNN) algorithms. It includes methods for majority and weighted voting based on nearest neighbors, calculation of centroids for labeled data, and label assignment based on nearest centroids. This module is designed to facilitate the propagation of labels from a reference dataset with known labels to a query dataset where labels are unknown.">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Single-Cell-Fuzzy-Labels</span>
    </a>
  </div>
        <div class="quarto-navbar-tools">
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./knn_label_transfer.html">KNN Label Transfer</a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Single-Cell-Fuzzy-Labels</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./download_embeddings_census.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Download Embeddings CELLxGENE</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./knn_label_transfer.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">KNN Label Transfer</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./label_set_harmonisation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Label Set Harmonisation</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./embed_data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Embedding a dataset of choice</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./visualization .html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Visualising the label transfer</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#majority-voting-method" id="toc-majority-voting-method" class="nav-link active" data-scroll-target="#majority-voting-method">Majority Voting Method</a>
  <ul class="collapse">
  <li><a href="#knn_majority_voting" id="toc-knn_majority_voting" class="nav-link" data-scroll-target="#knn_majority_voting">knn_majority_voting</a></li>
  </ul></li>
  <li><a href="#weighted-voting-method" id="toc-weighted-voting-method" class="nav-link" data-scroll-target="#weighted-voting-method">Weighted Voting Method</a>
  <ul class="collapse">
  <li><a href="#knn_weighted_voting" id="toc-knn_weighted_voting" class="nav-link" data-scroll-target="#knn_weighted_voting">knn_weighted_voting</a></li>
  </ul></li>
  <li><a href="#centroid-based-label-assignment" id="toc-centroid-based-label-assignment" class="nav-link" data-scroll-target="#centroid-based-label-assignment">Centroid-Based Label Assignment</a>
  <ul class="collapse">
  <li><a href="#calculate_centroids" id="toc-calculate_centroids" class="nav-link" data-scroll-target="#calculate_centroids">calculate_centroids</a></li>
  <li><a href="#assign_labels_by_nearest_centroid" id="toc-assign_labels_by_nearest_centroid" class="nav-link" data-scroll-target="#assign_labels_by_nearest_centroid">assign_labels_by_nearest_centroid</a></li>
  </ul></li>
  <li><a href="#running-the-label-transfer" id="toc-running-the-label-transfer" class="nav-link" data-scroll-target="#running-the-label-transfer">Running the Label Transfer</a>
  <ul class="collapse">
  <li><a href="#labels" id="toc-labels" class="nav-link" data-scroll-target="#labels">labels</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/Eamonmca/Single-Cell-Fuzzy-Labels/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">KNN Label Transfer</h1>
</div>

<div>
  <div class="description">
    The <code>KNN_Label_transfer</code> module provides functionality for label transfer between datasets using k-nearest neighbors (KNN) algorithms. It includes methods for majority and weighted voting based on nearest neighbors, calculation of centroids for labeled data, and label assignment based on nearest centroids. This module is designed to facilitate the propagation of labels from a reference dataset with known labels to a query dataset where labels are unknown.
  </div>
</div>


<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->
<p>We will utilize FAISS to identify the nearest neighbor for each cell in the query dataset from the reference dataset. After identifying the nearest neighbor, we will assign the annotation of the cell in the query dataset to match the annotation of its nearest neighbor in the reference dataset. Thanks to Meta’s optimization of FAISS, we can perform these nearest neighbor searches in batches and on the GPU, which significantly speeds up the process. The IndexFlatL2 function is used to calculate the L2 (or Euclidean) distance between all points in our query vector and the vectors in the reference index. A diagram illustrating this process is provided below. For more detailed information on vector searches and maximizing the use of FAISS, refer to the link provided (image credit also included).</p>
<p>When the K value in our K-Nearest Neighbors (KNN) algorithm is set to more than one neighbor, we need a method to determine the final predicted label. This is essential for ensuring the accuracy and reliability of our classification tasks. Below, we will implement three methods for this purpose:</p>
<section id="majority-voting-method" class="level1">
<h1>Majority Voting Method</h1>
<p>The Majority Voting Method is a technique used to determine the final label for each data point in the query dataset. This is achieved by conducting a simple majority vote among the labels of the K nearest neighbors in the reference dataset. The process involves the following steps:</p>
<ol type="1">
<li><strong>Neighbor Identification</strong>: For every data point in the query dataset, the K nearest neighbors in the reference dataset are identified.</li>
<li><strong>Vote Counting</strong>: The labels of these K neighbors are tallied.</li>
<li><strong>Label Assignment</strong>: The label with the highest tally is assigned to the query data point.</li>
</ol>
<p>It is important to note that this method assumes that each of the K neighbors has equal significance.</p>
<hr>
<p><a href="https://github.com/Eamonmca/Single-Cell-Fuzzy-Labels/blob/main/Single_Cell_Fuzzy_Labels/transfer.py#L10" target="_blank" style="float:right; font-size:smaller">source</a></p>
<section id="knn_majority_voting" class="level3">
<h3 class="anchored" data-anchor-id="knn_majority_voting">knn_majority_voting</h3>
<blockquote class="blockquote">
<pre><code> knn_majority_voting (indices:List[List[int]], reference_labels:List[str])</code></pre>
</blockquote>
<p>Assigns labels to query dataset points using majority voting from k-nearest neighbors.</p>
<table class="table">
<colgroup>
<col style="width: 9%">
<col style="width: 38%">
<col style="width: 52%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>indices</td>
<td>typing.List[typing.List[int]]</td>
<td>A list of lists, where each sublist contains the indices of the k-nearest neighbors in the reference dataset for a given query point.</td>
</tr>
<tr class="even">
<td>reference_labels</td>
<td>typing.List[str]</td>
<td>A list of labels corresponding to the points in the reference dataset.</td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>typing.List[str]</strong></td>
<td><strong>A list of labels for each point in the query dataset, determined by majority voting.</strong></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="weighted-voting-method" class="level1">
<h1>Weighted Voting Method</h1>
<p>The Weighted Voting Method is a technique that considers both the labels and the distances of the K nearest neighbors from the reference dataset. This method is especially beneficial when the neighbors are at different distances from the query point. The process involves the following steps:</p>
<ol type="1">
<li>Neighbor and Distance Identification: For each query point, the K nearest neighbors and their distances from the query point are identified.</li>
<li>Weighted Vote Calculation: Each neighbor is assigned a weight based on its distance (neighbors closer to the query point are given higher weight).</li>
<li>Vote Aggregation: The weighted votes for each label are aggregated.</li>
<li>Label Assignment: The label with the highest aggregated weight is assigned to the query point.</li>
</ol>
<p>This method allows neighbors that are closer to the query point to have more influence, potentially leading to more accurate predictions, especially in scenarios where the nearest neighbors are not uniformly distributed around the query point.</p>
<hr>
<p><a href="https://github.com/Eamonmca/Single-Cell-Fuzzy-Labels/blob/main/Single_Cell_Fuzzy_Labels/transfer.py#L30" target="_blank" style="float:right; font-size:smaller">source</a></p>
<section id="knn_weighted_voting" class="level3">
<h3 class="anchored" data-anchor-id="knn_weighted_voting">knn_weighted_voting</h3>
<blockquote class="blockquote">
<pre><code> knn_weighted_voting (indices:List, distances:List, reference_labels:List)</code></pre>
</blockquote>
<p>Assigns labels to query dataset points using weighted voting from k-nearest neighbors.</p>
<table class="table">
<colgroup>
<col style="width: 9%">
<col style="width: 38%">
<col style="width: 52%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>indices</td>
<td>typing.List</td>
<td>A list of lists, where each sublist contains the indices of the k-nearest neighbors in the reference dataset for a given query point.</td>
</tr>
<tr class="even">
<td>distances</td>
<td>typing.List</td>
<td>A list of lists, where each sublist contains the distances of the k-nearest neighbors from a given query point.</td>
</tr>
<tr class="odd">
<td>reference_labels</td>
<td>typing.List</td>
<td>A list of labels corresponding to the points in the reference dataset.</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>typing.List[str]</strong></td>
<td><strong>A list of labels for each point in the query dataset, determined by weighted voting.</strong></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="centroid-based-label-assignment" class="level1">
<h1>Centroid-Based Label Assignment</h1>
<p>The Centroid-Based Label Assignment method assigns labels to data points in a query dataset based on their closeness to the centroids of different classes in a reference dataset. The centroids are the average position of all points within a specific class. Here’s a detailed breakdown of the process:</p>
<ol type="1">
<li><p><strong>Centroid Calculation</strong>: For each label in the reference dataset, compute the centroid. A centroid is the arithmetic mean position of all the points sharing the same label. This step involves adding up all data points of each label and dividing by the total number of points for that label.</p></li>
<li><p><strong>Label Assignment by Nearest Centroid</strong>: For each point in the query dataset, identify its closest centroid. The closest centroid is the one with the least Euclidean distance from the query point. The label of this nearest centroid is then assigned to the query point.</p></li>
</ol>
<p>This method operates under the assumption that data points of the same class are typically clustered together, with the centroid serving as the central point of these clusters. It is particularly useful in situations where data points of the same class form distinct, compact clusters. However, its performance may be suboptimal in scenarios where the class distribution is highly irregular or overlapping.</p>
<hr>
<p><a href="https://github.com/Eamonmca/Single-Cell-Fuzzy-Labels/blob/main/Single_Cell_Fuzzy_Labels/transfer.py#L54" target="_blank" style="float:right; font-size:smaller">source</a></p>
<section id="calculate_centroids" class="level3">
<h3 class="anchored" data-anchor-id="calculate_centroids">calculate_centroids</h3>
<blockquote class="blockquote">
<pre><code> calculate_centroids (reference_data:List[List[float]],
                      reference_labels:List[str])</code></pre>
</blockquote>
<p>Calculates the centroids for each label in the reference dataset.</p>
<table class="table">
<colgroup>
<col style="width: 9%">
<col style="width: 38%">
<col style="width: 52%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>reference_data</td>
<td>typing.List[typing.List[float]]</td>
<td>A list of lists, where each sublist represents a data point in the reference dataset.</td>
</tr>
<tr class="even">
<td>reference_labels</td>
<td>typing.List[str]</td>
<td>A list of labels corresponding to the points in the reference dataset.</td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>typing.Dict[str, numpy.ndarray]</strong></td>
<td><strong>Returns a dictionary where each key is a label and the corresponding value is the centroid of that label.</strong></td>
</tr>
</tbody>
</table>
<hr>
<p><a href="https://github.com/Eamonmca/Single-Cell-Fuzzy-Labels/blob/main/Single_Cell_Fuzzy_Labels/transfer.py#L80" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="assign_labels_by_nearest_centroid" class="level3">
<h3 class="anchored" data-anchor-id="assign_labels_by_nearest_centroid">assign_labels_by_nearest_centroid</h3>
<blockquote class="blockquote">
<pre><code> assign_labels_by_nearest_centroid (query_data:List[List[float]],
                                    centroids:Dict[str,numpy.ndarray])</code></pre>
</blockquote>
<p>Assigns labels to each point in the query dataset based on the nearest centroid.</p>
<table class="table">
<colgroup>
<col style="width: 9%">
<col style="width: 38%">
<col style="width: 52%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>query_data</td>
<td>typing.List[typing.List[float]]</td>
<td>A list of lists, where each sublist represents a data point in the query dataset.</td>
</tr>
<tr class="even">
<td>centroids</td>
<td>typing.Dict[str, numpy.ndarray]</td>
<td>A dictionary where each key is a label and the corresponding value is the centroid of that label.</td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>typing.List[str]</strong></td>
<td><strong>Returns a list of labels assigned to each point in the query dataset based on the nearest centroid.</strong></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="running-the-label-transfer" class="level1">
<h1>Running the Label Transfer</h1>
<p>The following section of code implements our label transfer algorithm using FAISS. This function is designed to produce a very simple label transfer under default conditions, i.e., when ( k = 1 ). In this case, there is no need for label consensus as there is only one nearest neighbor.</p>
<p>However, the function also provides the flexibility to vary ( k ), the number of nearest neighbors considered for label assignment. When ( k &gt; 1 ), a label consensus method is required to decide the label for the query point based on the labels of its ( k ) nearest neighbors. The function supports three label consensus methods: ‘majority_voting’, ‘weighted_voting’, and ‘centroid_based’.</p>
<p>‘majority_voting’ assigns the label that appears most frequently among the ( k ) nearest neighbors. In case of a tie, it selects the label of the closest neighbor among the tied labels.</p>
<p>‘weighted_voting’ assigns the label based on a weighted vote where closer neighbors have a higher weight. The weight of each neighbor is inversely proportional to its distance from the query point.</p>
<p>‘centroid_based’ assigns labels to data points in the query dataset based on their closeness to the centroids of different classes in the reference dataset. This method is particularly useful in situations where data points of the same class form distinct, compact clusters.</p>
<p>The function also allows the distance metric to be varied according to any metric supported by FAISS. This provides additional flexibility in handling different types of data distributions.</p>
<hr>
<p><a href="https://github.com/Eamonmca/Single-Cell-Fuzzy-Labels/blob/main/Single_Cell_Fuzzy_Labels/transfer.py#L108" target="_blank" style="float:right; font-size:smaller">source</a></p>
<section id="labels" class="level3">
<h3 class="anchored" data-anchor-id="labels">labels</h3>
<blockquote class="blockquote">
<pre><code> labels (embedding_array_reference:numpy.ndarray,
         embedding_array_query:numpy.ndarray, reference_labels:List[str],
         k:int=1, use_gpu:bool=True, batch_size:Optional[int]=None,
         distance_metric:str='L2', label_consensus:str='majority_voting',
         timed:bool=False)</code></pre>
</blockquote>
<p>Transfers labels from a reference dataset to a query dataset using FAISS.</p>
<table class="table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>embedding_array_reference</td>
<td>ndarray</td>
<td></td>
<td>A numpy array representing the reference dataset.</td>
</tr>
<tr class="even">
<td>embedding_array_query</td>
<td>ndarray</td>
<td></td>
<td>A numpy array representing the query dataset.</td>
</tr>
<tr class="odd">
<td>reference_labels</td>
<td>typing.List[str]</td>
<td></td>
<td>A list of labels for the reference dataset.</td>
</tr>
<tr class="even">
<td>k</td>
<td>int</td>
<td>1</td>
<td>The number of nearest neighbors to consider for label assignment.</td>
</tr>
<tr class="odd">
<td>use_gpu</td>
<td>bool</td>
<td>True</td>
<td>Whether to use GPU for computation.</td>
</tr>
<tr class="even">
<td>batch_size</td>
<td>typing.Optional[int]</td>
<td>None</td>
<td>The size of the batch for computation. If None, the entire query dataset is processed in one batch.</td>
</tr>
<tr class="odd">
<td>distance_metric</td>
<td>str</td>
<td>L2</td>
<td>The distance metric to use. Can be ‘L2’ or ‘IP’.</td>
</tr>
<tr class="even">
<td>label_consensus</td>
<td>str</td>
<td>majority_voting</td>
<td>The label consensus method to use. Can be ‘majority_voting’, ‘weighted_voting’, or ‘centroid_based’.</td>
</tr>
<tr class="odd">
<td>timed</td>
<td>bool</td>
<td>False</td>
<td>Whether to return the time taken for label transfer.</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>typing.Union[typing.List[str], typing.Tuple[typing.List[str], float]]</strong></td>
<td></td>
<td><strong>Returns a list of labels for the query dataset. If timed is True, also returns the time taken for label transfer.</strong></td>
</tr>
</tbody>
</table>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/Eamonmca/Single-Cell-Fuzzy-Labels/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></div></div></footer></body></html>